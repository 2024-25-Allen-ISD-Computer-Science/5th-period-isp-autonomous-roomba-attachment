#include <Vector.h>
#include <SvgParser.h>
#include <SD.h>
#include  <Servo.h>
#include <Stepper.h>
Servo zServo;
const int stepsPerRev = x; // set based on the motor's specifications
Stepper xStepper(stepsPerRev, 2, 3, 4, 5);
Stepper yStepper(stepsPerRev, 6, 7, 8, 9);
const int feedRate = 100;
void setup() {
  zServo.attach(10); // connects the servo motor to pin 10
  xStepper.setSpeed(60); // sets the stepper speed of the xStepper
  yStepper.setSpeed(60);
  penServo.write(penUp); //starts the pen above the paper
  
  Serial.begin(6744); //starts serial communciation sets baud rate 6744

  //Vector for storing elements 
  std::vector<string*> storeDraw;

  SD.begin(4);
  
  //Load SVG file
  SvgParser svgDraw;
  svgDraw.readFile("/drawing.svg");

  
  SvgElement element; //stores information about the svg element
  while (svgDraw.next(&element)) { //gets next svg element and stores it in the element object
    storeDraw.push_back(element.data);
  }
  
}

void loop() {
  Serial.println("right"); //sends right to the serial monitor
  xStepper.step(10); //moves the stepper right 10
  pathsize = storeDraw.size()
  for (int i = 0; i < pathsize; i++) {
    readPath(storeDraw[i])
  }
  
}
void readPath(const std::string &pathData) {
  std::vector<std::string> tokens = tokenizePath(pathData);
  Point start = {0.0, 0.0};
  Point current = {0.0, 0.0}
  std::vector<std::string> gcode;
  int i = 0;
  while(i<tokens.length()) {
    std::string token = tokens[i];
    if(token == "M" || token == "m" {
      if(i + 2 >= tokens.length()) {
        break;
      } 
      //gets the tokens behind the M command
      float x = std::stof(tokens[i+1]);
      float y = std::stof(tokens[i+2]);
      i += 3;
      //makes sure pen is positioned correctly
      if (penDown) {
        gcode.push_back("M3 ; Pen Up");
        penDown = false;
      }
      //creates a string stream which allows for easy connection of strings
      std::ostringstream mCode;
      mCode << "G0 X" << x << " Y" << y;
      //pushes the gcode to 
      gcode.push_back(mCode.str());
      current = {x, y};
      startPoint = current;
    }else if(token == "L" || token == "l"){ //Line command - draws a line
      if(i + 2 >= tokens.length()) {
        break;
      } 
      float x = std::stof(tokens[i+1]);
      float y = std::stof(tokens[i+2]);
      i += 3;
      if (!penDown) {
        gcode.push_back("M3 ; Pen Down");
        penDown = false;
      }
      //creates a string stream to add to the gcode main string
      std::ostringstream lCode;
      lCode << "G1 X" << x << " Y" << y << " F" << feedRate;
      //pushes the gcode to 
      gcode.push_back(lCode.str());
      current = {x, y};
      startPoint = current;
    }else if(token == "H" || token == "h") {
      if (i + 1 >= tokens.size()) {
        break;
      }
        
      float x = std::stof(tokens[i + 1]);
      i += 2;
      if (!penDown) {
           gcode.push_back("M3 ; Pen Down");
           penDown = true;
      }

    }else if(token == "Q" || token =="q") {
      //Quadratic Bezier curve.
      //four params: x1, y1, x, y
      if(i+4 >= tokens.size()){
        break;
      }
      Point p1 = current;
      Point p2 = {std::stof(tokens[i+1]), std::stof(tokens[i+2])}
      Point p3 = {std::stof(tokens[i+3]), std::stof(tokens[i+4])}
      i+=5;
      std::vector<Point> pointsApproximated = QuadraticBezierCurve(p1, p2, p3, 10);
      for (size_t j = 1; j < curvePoints.size(); j++) {
              if (!penDown) {
                  gcode.push_back("M3 ; Pen Down");
                  penDown = true;
              }
              std::ostringstream oss;
              oss << "G1 X" << curvePoints[j].x << " Y" << curvePoints[j].y << " F" << feedRate;
              gcode.push_back(oss.str());
      }
      current = p3;
      
    }
    i++;
    else if (token == "Z" || token == "z") {
          i++;
          if (!penDown) {
              gcode.push_back("M3 ; Pen Down");
              penDown = true;
          }
          std::ostringstream oss;
          oss << "G1 X" << startPoint.x << " Y" << startPoint.y << " F" << feedRate;
          gcode.push_back(oss.str());
          current = startPoint;
          gcode.push_back("M5 ; Pen Up");
          penDown = false;
    }

  }
}
std::vector<std::string> tokenizePath(const std::string &data) {
    std::vector<std::string> tokensPath;
    std::string token;
    for(int i = 0; i < data.length(); i++){
        char c = data[i];
        if(std::isspace(c) || c == ','){
            if (!token.empty()) {
                tokensPath.push_back(token);
                token.clear();
            }
        }else if(std::isalpha(c)){
            if (!token.empty()) {
                tokensPath.push_back(token);
                token.clear();
            }
            tokensPath.push_back(std::string(1, c));
        }else{
            token.push_back(c);
        }
    }
    if(!token.empty()){
        tokensPath.push_back(token);
    }
  return tokensPath;
}
//appoximates bezier curve by dividing it into line segments, more line segments more accurate curve
std::vector<Point> QuadraticBezierCurve(Point p1, Point p2, Point p3, int segments) {
  //p1 starting point
  //p2 control point
  //p3 end point
  std::vector<Point> points; //vector that stores the points compute from the Quadratic bezier curve.
  for(int i =0; i<=segments; i++) {
    float t = float(i)/float(segments); //casts into float and divides by segments finds t which is a value between 0 to 1.
    float mt = 1.0f-t; //simplifies calculations
    float x = mt*mt*p1.x+2*mt*t*p2.x+t*t*p3.x; 
    float y = mt*mt*p1.y+2*mt*t*p2.y+t*t*p2.y;
    points.push_back({x, y});
  }
  return points;
}
void moveTo(Float x, float y) {
  stepperX.moveTo(x);
  stepperY.movetTo(y);
  stepperX.runToPosition();
  stepperY.runToPosition();
}
